---
layout: lecture
title: Technical Tasks in Software Engineering
permalink: /lectures/technical-tasks
parent: Modules
---

# Technical Tasks in Software Engineering

Building software is a complex process that involves a series of interconnected tasks. These tasks are often performed in a systematic way to ensure the software is built correctly, meets the needs of its users, and is maintainable in the long run. In this section, we will explore the key technical tasks involved in the software development lifecycle.

## Overview

The software development lifecycle (SDLC) is a framework that describes the stages involved in creating and maintaining software. While different methodologies have different ways of structuring these stages, several core technical tasks are common to most approaches. Understanding these tasks is crucial for anyone involved in software engineering.

## Requirements Elicitation

The first step in building software is understanding what needs to be built. **Requirements elicitation** is the process of gathering and discovering the needs and constraints of the stakeholders. This involves interacting with users, customers, and other relevant parties to understand their problems, goals, and expectations for the software.

It's a crucial step because if you don't understand the requirements correctly, the resulting software will not meet the users' needs, regardless of how well it is coded or tested.

Common techniques for requirements elicitation include:

*   **Interviews:** One-on-one discussions with stakeholders.
*   **Surveys and Questionnaires:** Gathering information from a larger group.
*   **Workshops:** Collaborative sessions with multiple stakeholders.
*   **Observing Users:** Watching how users perform their tasks in their environment.

## Requirements Analysis

Once requirements are gathered, they need to be analyzed, refined, and organized. **Requirements analysis** is the process of examining the gathered requirements to ensure they are complete, consistent, unambiguous, and feasible. This stage involves understanding the relationships between different requirements and identifying any potential conflicts or missing information.

Techniques used in requirements analysis include:

*   **Use Cases:** Describing how users will interact with the system to achieve specific goals.
*   **User Stories:** Short, simple descriptions of a feature from the perspective of the user.
*   **Data Flow Diagrams (DFDs):** Visualizing the flow of data through a system.

## Design

With a clear understanding of the requirements, the next task is to design the software's architecture and components. **Software design** involves creating a plan or blueprint for the software system. This includes deciding on the overall structure (architecture), how different parts of the system will interact, and the details of individual components.

Software design can be broken down into different levels:

*   **Architectural Design:** Deciding on the high-level structure of the system, such as choosing an architectural pattern (e.g., client-server, microservices).
*   **Detailed Design:** Designing the specific classes, modules, and interfaces within the system.

Good design principles aim for modularity, low coupling, high cohesion, and readability.

## Coding

**Coding**, also known as implementation, is the task of translating the software design into executable code using a programming language. This is the stage where programmers write the actual instructions that the computer will follow.

While coding is often what people think of first when they hear "programming," in software engineering, it's just one part of a larger process. Emphasis is placed on writing clean, readable, maintainable, and efficient code that adheres to coding standards. Version control systems are essential tools in this stage to manage changes to the codebase.

## Testing

Once the code is written, it needs to be verified and validated to ensure it functions correctly and meets the requirements. **Testing** is the process of executing the software with the intent of finding defects or bugs.

There are different levels and types of testing:

*   **Unit Testing:** Testing individual components or units of code in isolation.
*   **Integration Testing:** Testing how different units or components work together.
*   **System Testing:** Testing the complete, integrated system to verify it meets the specified requirements.
*   **Acceptance Testing:** Formal testing conducted to determine whether a system satisfies its acceptance criteria and to enable the customer to determine whether or not to accept the system.

Test-Driven Development (TDD) is a development practice where tests are written before the code is implemented.

## Acceptance Testing

**Acceptance testing** is a crucial stage where the stakeholders (often the customers or end-users) formally test the software to ensure it meets their needs and expectations. This is the final phase of testing before the software is released. The goal is to determine if the system satisfies the acceptance criteria agreed upon earlier. The stakeholders decide whether to accept or reject the software based on the results of acceptance testing.

---

## Interactive Elements

### Matching Activity

Match the technical task with its description.

[Placeholder for Matching Activity]

### Case Study

Consider a project to build an online library system. Describe the technical tasks you would expect to be involved in developing this system.

[Placeholder for Case Study]